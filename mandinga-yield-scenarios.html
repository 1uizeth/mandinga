<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mandinga — Circle Simulator</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Inter', system-ui, sans-serif; background: #0a0a0a; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

/* ── Header ── */
.hdr { padding: 10px 16px; border-bottom: 1px solid #1a1a1a; display: flex; align-items: center; gap: 16px; flex-shrink: 0; }
.hdr h1 { font-size: 0.9rem; font-weight: 700; color: #fff; letter-spacing: -0.01em; }
.hdr .sub { font-size: 0.65rem; color: #383838; }

/* ── Controls ── */
.ctrl { padding: 8px 16px; background: #0d0d0d; border-bottom: 1px solid #1a1a1a; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; flex-shrink: 0; }
.cg { display: flex; align-items: center; gap: 6px; }
.cl { font-size: 0.58rem; text-transform: uppercase; letter-spacing: 0.08em; color: #3a3a3a; white-space: nowrap; }
.cv { font-size: 0.8rem; font-weight: 700; min-width: 32px; }
input[type=range] { width: 72px; height: 3px; cursor: pointer; display: block; accent-color: #7c6af7; }
input[type=range].gr { accent-color: #4ade80; }
input[type=range].yw { accent-color: #facc15; }
.sep { width: 1px; height: 18px; background: #1e1e1e; flex-shrink: 0; }

/* ── Buttons ── */
.btn { display: inline-flex; align-items: center; gap: 4px; padding: 5px 10px; border-radius: 5px; font-size: 0.7rem; font-weight: 600; font-family: inherit; cursor: pointer; border: 1px solid; white-space: nowrap; }
.btn-g { background: #0d2b1a; color: #4ade80; border-color: #1a4a2a; }
.btn-g:hover { background: #1a4a2a; }
.btn-p { background: #1e1535; color: #a695f0; border-color: #3d3470; }
.btn-p:hover { background: #2a1f4a; }
.btn-y { background: #2b2000; color: #facc15; border-color: #4a3d00; }
.btn-y:hover { background: #3a2d00; }
.btn-r { background: #2b0d0d; color: #f87171; border-color: #4a1a1a; }
.btn-r:hover { background: #3a1515; }
.btn-d { background: #111; color: #555; border-color: #252525; }
.btn-d:hover { color: #888; border-color: #383838; }
.btn-sm { padding: 3px 8px; font-size: 0.62rem; }

/* ── Add user form ── */
.add-form { background: #0c0c0c; border-bottom: 1px solid #1a1a1a; padding: 8px 16px; display: none; align-items: center; gap: 10px; flex-wrap: wrap; flex-shrink: 0; }
.add-form.open { display: flex; }
.ff { display: flex; flex-direction: column; gap: 3px; }
.ff label { font-size: 0.56rem; text-transform: uppercase; letter-spacing: 0.08em; color: #3a3a3a; }
.fi { background: #0a0a0a; border: 1px solid #252525; border-radius: 4px; color: #e0e0e0; font-size: 0.82rem; font-weight: 600; font-family: inherit; padding: 4px 8px; width: 72px; outline: none; }
.fi:focus { border-color: #5b4fb8; }
.fs { background: #0a0a0a; border: 1px solid #252525; border-radius: 4px; color: #e0e0e0; font-size: 0.72rem; font-family: inherit; padding: 4px 7px; outline: none; cursor: pointer; }
.fs option { background: #1a1a1a; }

/* ── Main 3-col layout ── */
.main { display: grid; grid-template-columns: 200px 1fr 1fr; flex: 1; overflow: hidden; }
.col { border-right: 1px solid #1a1a1a; display: flex; flex-direction: column; overflow: hidden; }
.col:last-child { border-right: none; }
.col-hd { padding: 8px 12px; background: #0d0d0d; border-bottom: 1px solid #1a1a1a; font-size: 0.58rem; text-transform: uppercase; letter-spacing: 0.09em; color: #383838; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
.col-hd .cnt { font-size: 0.7rem; font-weight: 700; color: #e0e0e0; }
.col-body { flex: 1; overflow-y: auto; padding: 10px; }
.col-body::-webkit-scrollbar { width: 3px; }
.col-body::-webkit-scrollbar-thumb { background: #1e1e1e; border-radius: 2px; }

/* ── User chips ── */
.uc { background: #0d0d0d; border: 1px solid #1e1e1e; border-radius: 6px; padding: 6px 9px; margin-bottom: 5px; display: flex; align-items: center; gap: 7px; }
.uc.q-self   { border-color: #2d2858; border-left: 3px solid #7c6af7; }
.uc.q-net    { border-color: #1a3a22; border-left: 3px solid #4ade80; }
.uc.q-trig   { border-color: #3a2d00; border-left: 3px solid #facc15; }
.uc.in-c     { opacity: 0.5; }
.uc.done     { opacity: 0.3; }
.uid { font-size: 0.62rem; font-weight: 700; color: #555; width: 26px; flex-shrink: 0; }
.uparam { flex: 1; }
.ud  { font-size: 0.78rem; font-weight: 700; color: #e0e0e0; line-height: 1.2; }
.ut  { font-size: 0.6rem; color: #444; }
.umode { font-size: 0.55rem; font-weight: 600; padding: 1px 5px; border-radius: 3px; flex-shrink: 0; }
.m-self { background: #1e1535; color: #7c6af7; }
.m-net  { background: #0d2b1a; color: #4ade80; }
.m-trig { background: #2b2000; color: #facc15; }
.ucid { font-size: 0.55rem; color: #383838; }

/* ── Buckets ── */
.bucket { background: #0d0d0d; border: 1px solid #1e1e1e; border-radius: 8px; padding: 9px 10px; margin-bottom: 8px; }
.bk-hd { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 6px; }
.bk-key { font-size: 0.78rem; font-weight: 700; color: #e0e0e0; }
.bk-sub { font-size: 0.6rem; color: #444; }
.bk-chips { display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 7px; min-height: 20px; }
.bchip { font-size: 0.6rem; font-weight: 600; padding: 2px 6px; border-radius: 3px; }
.bc-self { background: #1e1535; color: #7c6af7; border: 1px solid #3d3470; }
.bc-net  { background: #0d2b1a; color: #4ade80; border: 1px solid #1a4a2a; }
.bc-trig { background: #2b2000; color: #facc15; border: 1px solid #4a3d00; }
.bk-bar-t { background: #1a1a1a; border-radius: 2px; height: 3px; margin-bottom: 5px; }
.bk-bar-f { height: 100%; border-radius: 2px; background: #7c6af7; transition: width 0.3s; }
.bk-status { font-size: 0.62rem; color: #444; }
.bk-status.ok { color: #4ade80; }
.bk-status.forming { color: #facc15; }
.bk-formed { margin-top: 6px; padding-top: 6px; border-top: 1px solid #1a1a1a; }
.formed-circle-tag { display: inline-flex; align-items: center; gap: 4px; font-size: 0.6rem; padding: 2px 7px; border-radius: 3px; margin-right: 4px; margin-bottom: 2px; font-weight: 600; }
.fct-active { background: #2b2000; color: #facc15; border: 1px solid #4a3d00; }
.fct-done   { background: #111; color: #333; border: 1px solid #1a1a1a; }

/* ── Circle cards ── */
.cc { background: #0d0d0d; border: 1px solid #252525; border-radius: 8px; padding: 10px; margin-bottom: 8px; }
.cc.done { opacity: 0.55; }
.cc-hd { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.cc-id { font-size: 0.8rem; font-weight: 700; color: #fff; }
.cc-meta { font-size: 0.6rem; color: #444; }
.cc-round { font-size: 0.7rem; font-weight: 600; color: #7c6af7; }
.cc-members { display: flex; flex-wrap: wrap; gap: 3px; margin-bottom: 8px; }
.mc { border-radius: 5px; padding: 4px 5px; font-size: 0.58rem; border: 1px solid; min-width: 44px; text-align: center; }
.mc .mcp { font-size: 0.5rem; color: #444; line-height: 1; }
.mc .mcu { font-size: 0.68rem; font-weight: 700; line-height: 1.3; }
.mc .mcd { font-size: 0.5rem; line-height: 1; }
.mc.waiting    { background: #111; border-color: #1e1e1e; }
.mc.waiting .mcu  { color: #444; }
.mc.paying     { background: #1a1030; border-color: #3d3470; }
.mc.paying .mcu   { color: #9985e0; }
.mc.covered    { background: #0d2010; border-color: #1a4a2a; }
.mc.covered .mcu  { color: #4ade80; }
.mc.selected   { background: #2d1f00; border-color: #a06000; animation: sel-pulse 0.6s ease-in-out 2; }
.mc.selected .mcu { color: #fbbf24; }
.mc.obligation { background: #0d1020; border-color: #2d3060; }
.mc.obligation .mcu { color: #5b6ad0; }
.mc.completed  { background: #0a0a0a; border-color: #111; }
.mc.completed .mcu { color: #252525; }
@keyframes sel-pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
.cc-prog-t { background: #1a1a1a; border-radius: 2px; height: 3px; margin-bottom: 7px; overflow: hidden; }
.cc-prog-f { height: 100%; border-radius: 2px; background: #7c6af7; transition: width 0.4s; }
.cc-ft { display: flex; justify-content: space-between; align-items: center; }
.cc-stats { font-size: 0.6rem; color: #444; }
.cc-log { margin-top: 7px; padding-top: 7px; border-top: 1px solid #111; max-height: 56px; overflow-y: auto; }
.cc-log .le { font-size: 0.6rem; margin-bottom: 2px; color: #444; }
.le.ls { color: #facc15; }
.le.lc { color: #4ade80; }
.le.lp { color: #3d3470; }
.le.ld { color: #f87171; }

/* ── Bottom bar ── */
.btm { border-top: 1px solid #1a1a1a; display: grid; grid-template-columns: 280px 1fr; flex-shrink: 0; height: 110px; }
.pool-pnl { border-right: 1px solid #1a1a1a; padding: 10px 14px; }
.log-pnl  { padding: 8px 12px; overflow: hidden; }
.pnl-ttl { font-size: 0.56rem; text-transform: uppercase; letter-spacing: 0.09em; color: #333; margin-bottom: 7px; }
.pool-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
.pg { }
.pg-l { font-size: 0.55rem; color: #333; margin-bottom: 2px; }
.pg-v { font-size: 0.82rem; font-weight: 700; letter-spacing: -0.02em; }
.pg-bar { height: 3px; border-radius: 2px; margin-top: 3px; }
.ev-log { height: 72px; overflow-y: auto; }
.ev-log::-webkit-scrollbar { width: 2px; }
.ev-log::-webkit-scrollbar-thumb { background: #1e1e1e; }
.ev { font-size: 0.62rem; padding: 2px 0; border-bottom: 1px solid #0d0d0d; }
.ev .et { color: #2a2a2a; font-size: 0.55rem; margin-right: 5px; }
.ev.ej { color: #444; }
.ev.ef { color: #7c6af7; }
.ev.es { color: #facc15; }
.ev.ec { color: #4ade80; }
.ev.ed { color: #f87171; }
.ev.ek { color: #333; }

/* ── Empty state ── */
.es-empty { text-align: center; padding: 20px 10px; color: #252525; font-size: 0.7rem; }

/* ── Badge ── */
.bge { display: inline-flex; align-items: center; font-size: 0.6rem; font-weight: 600; padding: 2px 7px; border-radius: 4px; }
.bge-g { background: #0d2b1a; color: #4ade80; border: 1px solid #1a4a2a; }
.bge-y { background: #2b2000; color: #facc15; border: 1px solid #4a3d00; }
.bge-r { background: #2b0d0d; color: #f87171; border: 1px solid #4a1a1a; }
</style>
</head>
<body>

<!-- Header -->
<div class="hdr">
  <div>
    <h1>Mandinga — Circle Simulator</h1>
    <div class="sub">joinQueue() → kickoff() → executeRound() · observe intent, formation, execution, and safety net scenarios</div>
  </div>
</div>

<!-- Controls -->
<div class="ctrl">
  <div class="cg">
    <span class="cl">APY</span>
    <input type="range" id="c-apy" min="0.5" max="12" step="0.5" value="4.5" class="gr">
    <span class="cv" id="v-apy">4.5%</span>
  </div>
  <div class="cg">
    <span class="cl">Threshold</span>
    <input type="range" id="c-thr" min="10" max="100" step="5" value="70" class="yw">
    <span class="cv" id="v-thr">70%</span>
  </div>
  <div class="cg">
    <span class="cl">Min N</span>
    <input type="range" id="c-minn" min="2" max="20" step="1" value="6">
    <span class="cv" id="v-minn">6</span>
  </div>
  <div class="cg">
    <span class="cl">Pool $</span>
    <input type="range" id="c-pool" min="0" max="50000" step="1000" value="10000" class="gr">
    <span class="cv" id="v-pool">$10k</span>
  </div>
  <div class="sep"></div>
  <button class="btn btn-g" id="btn-qplay" onclick="toggleQPlay()">▶ Play</button>
  <button class="btn btn-d" id="btn-rplay" onclick="toggleRPlay()">▶ Rounds</button>
  <div class="sep"></div>
  <button class="btn btn-p" onclick="addRandom()">+ Random</button>
  <button class="btn btn-y" onclick="toggleForm()">+ Manual</button>
  <button class="btn btn-p" onclick="manualForm()">⚡ Form</button>
  <div class="sep"></div>
  <button class="btn btn-r" onclick="resetSim()">↺ Reset</button>
</div>

<!-- Manual add form -->
<div class="add-form" id="add-form">
  <div class="ff">
    <label>Installment D</label>
    <input type="text" class="fi" id="f-d" value="100" placeholder="100">
  </div>
  <div class="ff">
    <label>Duration</label>
    <div style="display:flex;gap:4px">
      <input type="text" class="fi" id="f-t" value="10" placeholder="10" style="width:50px">
      <select class="fs" id="f-tu">
        <option value="months" selected>mo</option>
        <option value="years">yr</option>
      </select>
    </div>
  </div>
  <div class="ff">
    <label>Mode</label>
    <select class="fs" id="f-mode" onchange="onModeChange()">
      <option value="self">Self-funded (default)</option>
      <option value="net">Safety net from start</option>
      <option value="trig">Triggers at round…</option>
    </select>
  </div>
  <div class="ff" id="f-trig-wrap" style="display:none">
    <label>Trigger round</label>
    <input type="text" class="fi" id="f-trig" value="3" style="width:50px">
  </div>
  <button class="btn btn-y btn-sm" onclick="addManual()">Add</button>
  <button class="btn btn-d btn-sm" onclick="toggleForm()">Cancel</button>
</div>

<!-- Main 3-column layout -->
<div class="main">

  <!-- Col 1: Intent Queue -->
  <div class="col">
    <div class="col-hd">
      <span>Intent Queue</span>
      <span class="cnt" id="q-cnt">0</span>
    </div>
    <div class="col-body" id="q-list">
      <div class="es-empty">Add users to see their intents here. Each intent declares D (installment) and T (duration).</div>
    </div>
  </div>

  <!-- Col 2: Circle Formation -->
  <div class="col">
    <div class="col-hd">
      <span>Circle Formation</span>
      <span class="cnt" id="f-cnt">0 circles</span>
    </div>
    <div class="col-body" id="f-area">
      <div class="es-empty">Intents with matching D and T are grouped here. The kickoff algorithm runs when a bucket reaches viable N.</div>
    </div>
  </div>

  <!-- Col 3: Active Circles -->
  <div class="col">
    <div class="col-hd">
      <span>Active Circles</span>
      <span class="cnt" id="c-cnt">0 active</span>
    </div>
    <div class="col-body" id="c-list">
      <div class="es-empty">Formed circles appear here. Step through rounds manually or use ▶ Rounds to auto-advance.</div>
    </div>
  </div>

</div>

<!-- Bottom: Pool + Log -->
<div class="btm">
  <div class="pool-pnl">
    <div class="pnl-ttl">Safety Net Pool</div>
    <div class="pool-grid">
      <div class="pg">
        <div class="pg-l">Total</div>
        <div class="pg-v" id="p-total" style="color:#e0e0e0">—</div>
      </div>
      <div class="pg">
        <div class="pg-l">Committed</div>
        <div class="pg-v" id="p-commit" style="color:#f87171">—</div>
        <div class="pg-bar" id="p-commit-bar" style="background:#f87171;width:0%"></div>
      </div>
      <div class="pg">
        <div class="pg-l">Available</div>
        <div class="pg-v" id="p-avail" style="color:#4ade80">—</div>
        <div class="pg-bar" id="p-avail-bar" style="background:#4ade80;width:100%"></div>
      </div>
      <div class="pg">
        <div class="pg-l">Recovered</div>
        <div class="pg-v" id="p-recov" style="color:#7c6af7">—</div>
      </div>
    </div>
  </div>
  <div class="log-pnl">
    <div class="pnl-ttl">Event Log — contract call trace</div>
    <div class="ev-log" id="ev-log">
      <div class="ev ek"><span class="et">—</span>Simulator ready. ▶ Play to generate random users, or + Manual to add one.</div>
    </div>
  </div>
</div>

<script>
// ── Math ──
const unitM = { months: 1, years: 12 };
const mr = apy => (1 + apy / 100) ** (1 / 12) - 1;
function lumpY(P, mo, mRate) { return P * ((1 + mRate) ** mo - 1); }
function dripY(D, n, pr) { let t = 0; for (let i = 0; i < n; i++) t += D * ((1 + pr) ** (n - i) - 1); return t; }
function fmtK(n) {
  if (n === 0) return '$0';
  if (n >= 10000) return '$' + (n/1000).toFixed(0) + 'k';
  if (n >= 1000) return '$' + (n/1000).toFixed(1) + 'k';
  return '$' + Math.round(n);
}
function fmtD(n) { return '$' + n.toFixed(2); }
const ordS = n => n + (n===1?'st':n===2?'nd':n===3?'rd':'th');
const ts = () => { const d = new Date(); return String(d.getMinutes()).padStart(2,'0')+':'+String(d.getSeconds()).padStart(2,'0'); };

// ── Simulation State ──
const S = {
  apy: 4.5, threshold: 0.70, poolTotal: 10000, minN: 6,
  users: new Map(),
  circles: new Map(),
  uid: 1, cid: 1,
  poolCommit: 0,   // worst-case reservation for active circles
  poolDeployed: 0, // actual coverage delivered so far
  poolRecovered: 0,
  events: [],
  qTimer: null, formTimer: null, rTimer: null, rPlaying: false
};

function poolAvail() { return Math.max(0, S.poolTotal - S.poolCommit); }

function log(type, msg) {
  S.events.unshift({ type, msg, t: ts() });
  if (S.events.length > 80) S.events.pop();
}

// ── Find viable N ──
// Pool must cover worst-case: poolBacked × (N-1) × D/2
// Yield: ≥ threshold % of N positions beat solo saving
function viableN(D, T, count, poolBacked) {
  const mRate = mr(S.apy);
  const upper = Math.min(count, 50);
  const lower = Math.max(2, S.minN);
  if (upper < lower) return 0;
  for (let N = upper; N >= lower; N--) {
    if (poolBacked > 0) {
      const need = poolBacked * (N - 1) * (D / 2);
      if (poolAvail() < need) continue;
    }
    const pool = D * N, rl = T / N, pr = (1 + mRate) ** rl - 1;
    let beat = 0;
    for (let p = 1; p <= N; p++) {
      if (lumpY(pool, (N - p) * rl, mRate) - dripY(D, N - p, pr) > 0.005) beat++;
    }
    if (beat / N >= S.threshold) return N;
  }
  return 0;
}

// ── Add user ──
function addUser(D, T, mode, trigAt) {
  const id = 'U' + S.uid++;
  S.users.set(id, { id, D, T, mode, trigAt: trigAt || null, circleId: null, status: 'queued' });
  log('j', `joinQueue(${id}) → D=${fmtK(D)}/round · T=${T}mo · mode=${mode}`);
  render();
}

// User profiles for random generation (weighted)
const PROFILES = [
  { D:100, T:10, w:30 }, { D:200, T:12, w:25 },
  { D:50,  T:6,  w:20 }, { D:150, T:24, w:15 }, { D:500, T:6, w:10 }
];
function pickProf() {
  const tot = PROFILES.reduce((s,p)=>s+p.w,0);
  let r = Math.random()*tot;
  for (const p of PROFILES) { r -= p.w; if (r <= 0) return p; }
  return PROFILES[0];
}
function addRandom() {
  const {D,T} = pickProf();
  const r = Math.random();
  let mode, trigAt = null;
  if      (r < 0.70) mode = 'self';
  else if (r < 0.85) mode = 'net';
  else { mode = 'trig'; trigAt = Math.max(1, Math.floor(Math.random() * Math.max(1, T/2)) + 1); }
  addUser(D, T, mode, trigAt);
}
function addManual() {
  const D = Math.max(1, parseInt(document.getElementById('f-d').value) || 100);
  const tV = parseFloat(document.getElementById('f-t').value) || 10;
  const T = Math.round(tV * unitM[document.getElementById('f-tu').value]);
  const mode = document.getElementById('f-mode').value;
  const trigAt = mode === 'trig' ? (parseInt(document.getElementById('f-trig').value) || 3) : null;
  addUser(D, T, mode, trigAt);
}

// ── Formation ──
function getBuckets() {
  const bk = new Map();
  for (const u of S.users.values()) {
    if (u.status !== 'queued') continue;
    const k = `${u.D}_${u.T}`;
    if (!bk.has(k)) bk.set(k, { D:u.D, T:u.T, users:[] });
    bk.get(k).users.push(u);
  }
  return bk;
}

function tryForm() {
  let again = true;
  while (again) {
    again = false;
    for (const bk of getBuckets().values()) {
      const { D, T, users } = bk;
      if (users.length < 2) continue;
      const backed = users.filter(u => u.mode !== 'self').length;
      const N = viableN(D, T, users.length, backed);
      if (N < 2) continue;
      doForm(users.slice(0, N), D, T, N);
      again = true;
      break;
    }
  }
}

function doForm(users, D, T, N) {
  const id = 'C' + S.cid++;
  const rl = T / N;
  // VRF position draw deferred to round 1 execution — positions unknown at formation
  const backed = users.filter(u => u.mode !== 'self').length;
  const commit = backed * (N-1) * (D/2);
  S.poolCommit += commit;

  const members = users.map(u => ({
    userId:u.id, D, position:null, mode:u.mode, trigAt:u.trigAt,
    covRounds:0, debt:0, selected:false, selRound:null, netPayout:null, yieldEarned:null, status:'waiting'
  }));

  S.circles.set(id, { id, N, D, T, rl, currentRound:0, members, poolCommit:commit, poolUsed:0, status:'active', log:[] });
  for (const u of users) { u.circleId = id; u.status = 'in-circle'; }
  log('f', `kickoff(${id}) → N=${N} · D=${fmtK(D)}/round · T=${T}mo · VRF pending (fires at R1)`);
  if (backed > 0) log('f', `${id} pool commit: ${fmtK(commit)} (${backed} backed × ${N-1} worst-case rounds × D/2)`);
}

// ── Round execution ──
function execRound(cid) {
  const c = S.circles.get(cid);
  if (!c || c.status !== 'active' || c.currentRound >= c.N) return;

  c.currentRound++;
  const r = c.currentRound;
  const { D, N, rl } = c;
  const mRate = mr(S.apy);
  const pool = D * N;

  // Transition previous 'selected' → 'obligation'
  for (const m of c.members) {
    if (m.status === 'selected') m.status = 'obligation';
  }

  // ── VRF: pick one random member from the unselected pool this round ──
  const eligible = c.members.filter(m => !m.selected);
  if (!eligible.length) return;
  const winner = eligible[Math.floor(Math.random() * eligible.length)];
  log('f', `${cid} R${r}: VRF draw · ${eligible.length} eligible → #${winner.userId.slice(1)} selected`);

  // ── selectMember() ──
  winner.position = r; // records which round they were picked
  winner.selected = true;
  winner.selRound = r;
  const holdMo = (N - r) * rl;
  const netPayout = Math.max(0, pool - winner.debt);
  const yieldEarned = lumpY(netPayout, holdMo, mRate);
  winner.netPayout = netPayout;
  winner.yieldEarned = yieldEarned;
  winner.status = 'selected';
  S.poolCommit    = Math.max(0, S.poolCommit - winner.debt);
  S.poolRecovered += winner.debt;
  c.poolUsed += winner.debt;
  c.log.unshift(`<span class="le ls">R${r}: #${winner.userId.slice(1)} SELECTED → pool=${fmtK(pool)} debt=-${fmtK(winner.debt)} net=${fmtK(netPayout)} yield=+${fmtD(yieldEarned)}</span>`);
  log('s', `${cid} R${r}: creditPayout(#${winner.userId.slice(1)}) → net ${fmtK(netPayout)} · yield est. +${fmtD(yieldEarned)} · debt cleared`);

  // ── contributeRound() for all remaining unselected members ──
  for (const m of eligible) {
    if (m === winner) continue;
    const useSN = m.mode === 'net' || (m.mode === 'trig' && m.trigAt !== null && r >= m.trigAt);
    if (useSN) {
      const covered = D / 2;
      m.covRounds++; m.debt += covered;
      S.poolDeployed += covered;
      m.status = 'covered';
      c.log.unshift(`<span class="le lc">R${r}: #${m.userId.slice(1)} safety net → pays D/2=${fmtK(covered)} · pool covers D/2 · debt now ${fmtK(m.debt)}</span>`);
      log('c', `${cid} R${r}: coverRound(#${m.userId.slice(1)}) → D/2 from pool · running debt ${fmtK(m.debt)}`);
    } else {
      m.status = 'paying';
      c.log.unshift(`<span class="le lp">R${r}: #${m.userId.slice(1)} paid ${fmtK(D)}</span>`);
    }
  }

  if (c.log.length > 10) c.log.length = 10;

  if (c.currentRound === c.N) {
    c.status = 'completed';
    const unused = Math.max(0, c.poolCommit - c.poolUsed);
    S.poolCommit = Math.max(0, S.poolCommit - unused);
    for (const m of c.members) {
      m.status = 'completed';
      const u = S.users.get(m.userId);
      if (u) u.status = 'completed';
    }
    log('k', `${cid} completed · all ${N} members received payout · pool released ${fmtK(unused)} unused commitment`);
  }
  render();
}

// ── Auto play ──
function toggleQPlay() {
  const btn = document.getElementById('btn-qplay');
  if (S.qTimer) {
    clearInterval(S.qTimer); S.qTimer = null;
    clearInterval(S.formTimer); S.formTimer = null;
    btn.className = 'btn btn-g'; btn.textContent = '▶ Play';
  } else {
    btn.className = 'btn btn-d'; btn.textContent = '⏸ Pause';
    S.qTimer = setInterval(addRandom, 1100);
    // Formation runs on a separate slower cycle so users can accumulate first
    S.formTimer = setInterval(() => { tryForm(); render(); }, 3500);
  }
}
function manualForm() { tryForm(); render(); }
function toggleRPlay() {
  const btn = document.getElementById('btn-rplay');
  S.rPlaying = !S.rPlaying;
  if (S.rPlaying) {
    btn.className = 'btn btn-g'; btn.textContent = '⏸ Rounds';
    S.rTimer = setInterval(() => {
      let found = false;
      for (const c of S.circles.values()) {
        if (c.status === 'active') { execRound(c.id); found = true; break; }
      }
      if (!found) { S.rPlaying = false; clearInterval(S.rTimer); btn.className = 'btn btn-d'; btn.textContent = '▶ Rounds'; }
    }, 700);
  } else {
    clearInterval(S.rTimer);
    btn.className = 'btn btn-d'; btn.textContent = '▶ Rounds';
  }
}
function resetSim() {
  if (S.qTimer) { clearInterval(S.qTimer); S.qTimer = null; }
  if (S.formTimer) { clearInterval(S.formTimer); S.formTimer = null; }
  if (S.rTimer) { clearInterval(S.rTimer); S.rTimer = null; }
  S.rPlaying = false;
  S.users.clear(); S.circles.clear();
  S.uid = 1; S.cid = 1;
  S.poolCommit = 0; S.poolDeployed = 0; S.poolRecovered = 0;
  S.events = [];
  document.getElementById('btn-qplay').className = 'btn btn-g';
  document.getElementById('btn-qplay').textContent = '▶ Play';
  document.getElementById('btn-rplay').className = 'btn btn-d';
  document.getElementById('btn-rplay').textContent = '▶ Rounds';
  log('k', 'Simulator reset — all state cleared');
  render();
}
function toggleForm() { document.getElementById('add-form').classList.toggle('open'); }
function onModeChange() {
  document.getElementById('f-trig-wrap').style.display =
    document.getElementById('f-mode').value === 'trig' ? 'flex' : 'none';
}

// ── Render ──
function renderQueue() {
  const el = document.getElementById('q-list');
  const all = [...S.users.values()];
  const qd = all.filter(u=>u.status==='queued').length;
  document.getElementById('q-cnt').textContent = qd + ' queued · ' + all.length + ' total';
  if (!all.length) { el.innerHTML = '<div class="es-empty">Add users to see their intents here.</div>'; return; }
  el.innerHTML = [...all].reverse().map(u => {
    const mc = u.mode==='self'?'m-self':u.mode==='net'?'m-net':'m-trig';
    const ml = u.mode==='self'?'self-funded':u.mode==='net'?'safety net':'net @R'+u.trigAt;
    const st = u.status==='queued'?`q-${u.mode}`:(u.status==='completed'?'done':'in-c');
    const cid = u.circleId?`<span class="ucid" style="color:#555;font-size:0.55rem">→ ${u.circleId}</span>`:'';
    const num = u.id.slice(1);
    return `<div class="uc ${st}">
      <span class="uid" style="color:#333;font-size:0.58rem;width:22px">#${num}</span>
      <div class="uparam">
        <div class="ud">${fmtK(u.D)}<span style="font-size:0.55rem;color:#444;font-weight:400"> /round</span></div>
        <div class="ut">${u.T} months</div>
      </div>
      <div style="display:flex;flex-direction:column;align-items:flex-end;gap:3px">
        <span class="umode ${mc}">${ml}</span>${cid}
      </div>
    </div>`;
  }).join('');
}

function renderFormation() {
  const el = document.getElementById('f-area');
  const bkts = getBuckets();

  // Build profile map including formed circles
  const profileMap = new Map(); // key → {D,T,queued:[],circles:[]}
  for (const [k,bk] of bkts) profileMap.set(k, { D:bk.D, T:bk.T, queued:bk.users, circles:[] });
  for (const c of S.circles.values()) {
    const k = `${c.D}_${c.T}`;
    if (!profileMap.has(k)) profileMap.set(k, { D:c.D, T:c.T, queued:[], circles:[] });
    profileMap.get(k).circles.push(c);
  }

  document.getElementById('f-cnt').textContent = S.circles.size + ' circle' + (S.circles.size!==1?'s':'');
  if (!profileMap.size) { el.innerHTML = '<div class="es-empty">Buckets of matching intents appear here.</div>'; return; }

  el.innerHTML = [...profileMap.values()].reverse().map(p => {
    const { D, T, queued, circles } = p;
    const backed = queued.filter(u=>u.mode!=='self').length;
    const N = queued.length >= 2 ? viableN(D, T, queued.length, backed) : 0;
    const progress = queued.length > 0 ? Math.min(queued.length / Math.max(N||2, 2) * 100, 100) : 0;
    const status = N >= 2
      ? `<span class="bk-status forming">⚡ N=${N} viable — kickoff running</span>`
      : queued.length > 0
        ? `<span class="bk-status">${queued.length} queued · min 2 needed</span>`
        : `<span class="bk-status">queue empty</span>`;

    const chips = [...queued].reverse().map(u => {
      const cc = u.mode==='self'?'bc-self':u.mode==='net'?'bc-net':'bc-trig';
      const ml = u.mode==='self'?'self':u.mode==='net'?'net':'@R'+u.trigAt;
      return `<span class="bchip ${cc}" title="${u.id}">#${u.id.slice(1)} ${ml}</span>`;
    }).join('');

    const formedTags = circles.length ? `<div class="bk-formed">` +
      [...circles].reverse().map(c => `<span class="formed-circle-tag ${c.status==='active'?'fct-active':'fct-done'}">${c.id} ${c.status==='active'?'R'+c.currentRound+'/'+c.N:'done'}</span>`).join('') +
      `</div>` : '';

    return `<div class="bucket">
      <div class="bk-hd">
        <span class="bk-key">${fmtK(D)}/round · ${T}mo</span>
        <span class="bk-sub">${queued.length+circles.reduce((s,c)=>s+c.N,0)} total members</span>
      </div>
      ${chips ? `<div class="bk-chips">${chips}</div>` : '<div class="bk-chips" style="color:#252525;font-size:0.62rem">no users queued</div>'}
      <div class="bk-bar-t"><div class="bk-bar-f" style="width:${progress}%"></div></div>
      ${status}
      ${formedTags}
    </div>`;
  }).join('');
}

function renderCircles() {
  const el = document.getElementById('c-list');
  const all = [...S.circles.values()];
  const active = all.filter(c=>c.status==='active').length;
  document.getElementById('c-cnt').textContent = active + ' active · ' + all.length + ' total';
  if (!all.length) { el.innerHTML = '<div class="es-empty">Formed circles appear here. Step through rounds manually or use ▶ Rounds.</div>'; return; }

  el.innerHTML = [...all].reverse().map(c => {
    const pool = c.D * c.N;
    const prog = c.N > 0 ? c.currentRound / c.N * 100 : 0;

    // Members in stable insertion order — position fills in as each round's VRF picks them
    const cells = c.members.map(m => {
      const icon = m.selected ? '✓' : m.status==='covered' ? '☂' : '';
      const debt = m.debt > 0 ? `<div class="mcd" style="color:#f87171">-${fmtK(m.debt)}</div>` : '';
      const net  = m.netPayout !== null ? `<div class="mcd" style="color:#facc15">${fmtK(m.netPayout)}</div>` : '';
      const modeDot = m.mode==='net'?'●':m.mode==='trig'?'◆':'';
      const modeDotColor = m.mode==='net'?'#4ade80':m.mode==='trig'?'#facc15':'transparent';
      // position is null until VRF picks this member
      const posLabel = m.position !== null ? `R${m.position}` : '—';
      const posColor = m.position !== null ? '#facc15' : '#282828';
      return `<div class="mc ${m.status}" title="${m.userId} · ${m.mode}${m.trigAt?' @R'+m.trigAt:''}">
        <div class="mcp" style="display:flex;justify-content:space-between"><span style="color:${posColor}">${posLabel}</span><span style="color:${modeDotColor};font-size:0.45rem">${modeDot}</span></div>
        <div class="mcu">#${m.userId.slice(1)}${icon}</div>
        ${debt}${net}
      </div>`;
    }).join('');
    const memberBlock = `<div class="cc-members">${cells}</div>`;

    const nextBtn = c.status === 'active'
      ? `<button class="btn btn-p btn-sm" onclick="execRound('${c.id}')">→ R${c.currentRound+1}</button>`
      : `<span class="bge bge-g">✓ Done</span>`;

    const roundInfo = c.currentRound > 0 ? `R${c.currentRound}/${c.N}` : 'ready';
    const poolUsedPct = pool > 0 ? (c.poolUsed / pool * 100).toFixed(0) : 0;

    const miniLog = c.log.length
      ? c.log.map(l=>`<div class="le">${l}</div>`).join('')
      : '<div class="le" style="color:#252525">No rounds executed yet.</div>';

    return `<div class="cc ${c.status==='completed'?'done':''}">
      <div class="cc-hd">
        <span class="cc-id">${c.id}</span>
        <span class="cc-meta">N=${c.N} · ${fmtK(c.D)}/rnd · ${c.T}mo</span>
        <span class="cc-round">${roundInfo}</span>
      </div>
      ${memberBlock}
      <div class="cc-prog-t"><div class="cc-prog-f" style="width:${prog}%"></div></div>
      <div class="cc-ft">
        <span class="cc-stats">pool=${fmtK(pool)} · pool used=${fmtK(c.poolUsed)} (${poolUsedPct}%)</span>
        <div style="display:flex;gap:4px">${nextBtn}</div>
      </div>
      <div class="cc-log">${miniLog}</div>
    </div>`;
  }).join('');
}

function renderPool() {
  const tot = S.poolTotal;
  const avail = poolAvail();
  document.getElementById('p-total').textContent = fmtK(tot);
  document.getElementById('p-commit').textContent = fmtK(S.poolCommit);
  document.getElementById('p-avail').textContent  = fmtK(avail);
  document.getElementById('p-recov').textContent  = fmtK(S.poolRecovered);
  const pct = n => Math.min(n / Math.max(tot, 1) * 100, 100) + '%';
  document.getElementById('p-commit-bar').style.width = pct(S.poolCommit);
  document.getElementById('p-avail-bar').style.width  = pct(avail);
}

function renderLog() {
  const el = document.getElementById('ev-log');
  if (!S.events.length) return;
  const cls = { j:'ej', f:'ef', s:'es', c:'ec', k:'ek', r:'ej' };
  el.innerHTML = S.events.map(e => `<div class="ev ${cls[e.type]||'ej'}"><span class="et">${e.t}</span>${e.msg}</div>`).join('');
}

function render() {
  // Sync params
  S.apy       = +document.getElementById('c-apy').value;
  S.threshold = +document.getElementById('c-thr').value / 100;
  S.poolTotal = +document.getElementById('c-pool').value;
  S.minN      = +document.getElementById('c-minn').value;
  document.getElementById('v-apy').textContent  = S.apy.toFixed(1) + '%';
  document.getElementById('v-thr').textContent  = Math.round(S.threshold*100) + '%';
  document.getElementById('v-pool').textContent = fmtK(S.poolTotal);
  document.getElementById('v-minn').textContent = S.minN;
  renderQueue(); renderFormation(); renderCircles(); renderPool(); renderLog();
}

// ── Events ──
['c-apy','c-thr','c-pool','c-minn'].forEach(id => document.getElementById(id).addEventListener('input', render));
render();
</script>
</body>
</html>
